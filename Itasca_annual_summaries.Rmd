---
title: "Itasca_annual_summaries"
author: "Sara DeLaurentis"
date: "4/11/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

  
library(lubridate)
library(stringr)
library(tidyverse)
library(cowplot)
library(stringr)
library(dplyr)
library(glue) #from dplyr


```



##Create a dataframe to enable selection of .csv files.

```{r }
#create list of .csv files
m <- list.files("C:/Users/sbaue/coding/R_TEMPRY/Itasca_project_19-21/iButtons", pattern = "*.csv")
m

file_df <- data.frame(paths = m, name = str_replace(m, ".csv", ""), full_paths = list.files("C:/Users/sbaue/coding/R_TEMPRY/Itasca_project_19-21/iButtons", pattern = "*.csv", full.names = TRUE))

file_df

meta <- file_df$name %>%   #take the name column 
   str_split_fixed("_", n=5) %>% #split the strings, with _ as separator.
   as.data.frame() #COERCE
  colnames(meta) <- c("site", "rep", "position", "buttonID", "season") #
  meta$CLEAN = NULL 
  
  
data.list.df <- cbind(file_df, meta)
  #  temp_df <- temp_df[, c(6,1,2,3,4,5,7,8)] # column re-ordering if necessary
data.list.df <- data.list.df[order(data.list.df$site, data.list.df$rep, data.list.df$position, data.list.df$season), ] #for checking stuff

data.list.df <- data.list.df[order(data.list.df$name),]

view(data.list.df)

```


### THIS IS THE CODE YOU'VE BEEN LOOKING FOR !!! ###
### VERY COOOlll lists ###

#What this does:

#1. Takes the dataframe we created from the names of the selected files, turns each ROW into ONE list element with "site", "rep", etc. as named elements contained inside.

#2. Uses lapply to read in the .csv files and attaches metadata.


```{r }

files.meta.list <- list()                   # Create empty list

for(i in 1:nrow(data.list.df)) {   #for(each variable in the sequence "1 through the number of rows in C2A"):
                          
  files.meta.list[[i]] <- data.list.df[i , ]  #create an element in files.meta.list from each row found in C2A
}
#print(files.meta.list)

#Step 2: 

csv_LIST <- lapply(seq_along(files.meta.list), function(i){   
  df <- read.csv(files.meta.list[[i]]$full_paths, header=TRUE, sep = ",") #create "df" by reading the .csv given by full_paths.
  df$site <- files.meta.list[[i]]$site    #next few rows are the addition of metadata columns based on the named element in the list. 
  df$rep <- files.meta.list[[i]]$rep
  df$position <- files.meta.list[[i]]$position
  df$buttonID <- files.meta.list[[i]]$buttonID
  df$season <- files.meta.list[[i]]$season
  #Converting the date.time column. There are multiple date formats that need to be dealt with.
  df$date.time <- if(grepl("M", df[1,"date.time"])){#    If there is an "M" present in the first row of date.time column (AM/PM), look for this format
    as.POSIXct(df$date.time, format = c("%m/%d/%Y %I:%M:%S %p"), origin = "1970-01-01 00:00:00 UTC", tz = "")
  }else{as.POSIXct(df$date.time, tz = "", tryFormats = c("%m/%d/%Y %H:%M", "%m/%d/%Y %H:%M:%S")) #if no "M", look for these formats instead.
  }
  df #VERY IMPORTANT. I don't know why, but without this call for the whole dataframe, you get left with just the last column you created.
  })

finalTable <- do.call(rbind, csv_LIST) ##JOIN TOGETHER

str(finalTable)
head(finalTable)
view(finalTable)
finalTable[(grep("2020-12-28", finalTable$date.time)),]

#output problem table if needed.
#problems <- finalTable %>% filter(is.na(date.time))
#view(problems)
#view(problems[problems$buttonID == "i45",])
#view(finalTable[finalTable$buttonID == "i101" & finalTable$season == "2021",])


#ggplot stuff:

#ggplot(finalTable, aes(x=as.POSIXct(date.time, format = "%m/%d/%Y %H:%M"), y=value, group = position, color = position)) + 
#  geom_line() + 
#  xlab("Date/Time") + 
#  ylab("Temperature in C")


```
## ANNOTATED COPY ##


### THIS IS THE CODE YOU'VE BEEN LOOKING FOR !!! ###
### VERY COOOlll lists ###

#What this does:

#1. Takes the dataframe we created from the names of the selected files, turns each ROW into ONE list element with "site", "rep", etc. as named elements contained inside.

#2. Uses lapply to read in the .csv files and attaches metadata.


```{r }

#Step 1: Turn each row of metadata into a list element with filenames, site, rep, etc. as named elements within.


files.meta.list <- list()                   # Create empty list


#Next, we can use a for-loop to store each row of our data frame as list element.

for(i in 1:nrow(data.list.df)) {   #for(each variable in the sequence "1 through the number of rows in C2A"):
                          
  files.meta.list[[i]] <- data.list.df[i , ]  #create an element in files.meta.list from each row found in C2A
}

#check it out: each element of the list (each [[x]]) contains the filenames and metadata, and they've maintained their column names as labels, so we can call out that named element when we want.

print(files.meta.list)


#Step 2: Use lapply to perform the following on each list element:
#Read .csv file given by the full_paths list element.
#Assign metadata columns based on the other named elements.
#Then, rbind all of those dataframes together for your finalTable

csv_LIST <- lapply(seq_along(files.meta.list), function(i){   #perform the given function along this list, each element in the list is the input.
  df <- read.csv(files.meta.list[[i]]$full_paths, header=TRUE, sep = ",") #create "df" by reading the .csv given by full_paths.
  df$site <- files.meta.list[[i]]$site    #next few rows are the addition of metadata columns based on the named element in the list. "Make a site column using the thing in the list at [[i]], that's labeled "site"
  df$rep <- files.meta.list[[i]]$rep
  df$position <- files.meta.list[[i]]$position
  df$buttonID <- files.meta.list[[i]]$buttonID
  df$season <- files.meta.list[[i]]$season
  df #VERY IMPORTANT. I don't know why, but without this call for the whole dataframe, you get left with just the last column you created.
  
  })

#finalTable <- do.call(rbind, csv_LIST) ##JOIN TOGETHER
#view(finalTable)

#ggplot(finalTable, aes(x=as.POSIXct(date.time, format = "%m/%d/%Y %H:%M"), y=value, group = position, color = position)) + 
#  geom_line() + 
#  xlab("Date/Time") + 
#  ylab("Temperature in C")


```


## Mean Annual Temperature Summaries ##

```{r }
data <- finalTable
head(data$date.time)
data[30000,]
class(data[4,"date.time"])

START <- as.POSIXct("2020-01-01")
BREAK <- as.POSIXct("2020-08-25")
RESUME <- as.POSIXct("2020-09-30")
END <- as.POSIXct("2020-12-31")

annual.sums.df <- data %>% 
  subset.data.frame(date.time >= START & date.time <= END) 
annual.sums.df <- annual.sums.df %>% 
  subset.data.frame(date.time <= BREAK | date.time >= RESUME)

#annual.sums.df <- data %>%                    
 #  subset.data.frame(date.time <= BREAK || date.time >= RESUME)
#filter(date.time >= START & date.time <= END) %>% 
 # group_by(site, rep, position, season) %>% 
 # summarise(meantemp = mean(value))

view(annual.sums.df)
str(annual.sums.df)
check <- annual.sums.df %>% 
  filter(date.time > as.POSIXct("2020-12-28", tz = ""))

view(annual.sums.df[annual.sums.df$date.time > as.POSIXct("2020-12-28"),])
view(check)


```